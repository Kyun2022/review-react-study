# Next js で学ぶ React 講座

## #1 React を学ぶには Next.js から入ると効率が良い理由。Next.js のセットアップから Vercel へのデプロイまで！

Next.js を使って React の講座を行う理由について説明します。React だけを使って構築することも可能ですが、React だけでは初心者にとって難しい点が多くあります。例えば、ルーティングの設定が特に難しい点です。Next.js では、ルーティングを簡単に設定できるほか、サーバーサイドレンダリングの実現が容易です。これらの点から、React を学ぶ上で Next.js を使用すると有益だと考えています。

Next.js には多くの機能がありますが、初心者にとってはすべてを覚えるのは難しいでしょう。そのため、最初は Next.js の基本的な機能を使って React を学ぶことに焦点を当てます。特に、イメージオプティマイゼーション、インターナショナリゼーション、API ルートなどの高度な機能は、初心者には必要ないと考えます。重要なのは、ファイルシステムルーティング、ビルトイン CSS サポート、ゼロコンフィグレーションの概念です。

セットアップの手順についても説明します。create-next-app を使用して新しい Next.js プロジェクトを始める方法、プロジェクトのファイル構造と主要なフォルダ（pages, public）の役割について解説します。また、dev、build、start スクリプトの違いや使用方法についても説明します。

この講座では、Next.js のプロジェクトを GitHub にプッシュし、Vercel を使ってデプロイする方法も取り上げます。これにより、実際の Web 開発のワークフローを体験し、プロジェクトをオンラインで公開する方法を学ぶことができます。

最後に、今後の講座で React と Next.js を使った具体的な開発プロジェクトについて学んでいく予定です。この講座は、React の基礎を学ぶ上での出発点となることを目指しています。

## #2 コンポーネントの作り方と、Next.js での静的ページの作り方を学ぼう

今日は React の講座第 2 弾ということで、React の特徴の一つであるコンポーネントベースについて紹介します。また、Next.js のファイルシステムルーティングの一部を紹介したいと思います。React のホームページを見てみると、大きく 3 つの特徴が書かれています。一番左側が宣言的なビューで、これは最初は理解が難しいかもしれません。従来の JavaScript や jQuery では命令的なビューで DOM を操作していましたが、React では宣言的なビューを作っていきます。これによって、状態の変化を意識せずにデータを与えるだけで UI が変わり、メンテナンス性が向上します。

真ん中のコンポーネントベースは、今回詳しく紹介したいと思います。右側の「一度学習すればどこでも使える」という特徴は、React が Node を使ったサーバー上でも動くこと、また React Native を使うことでモバイルアプリケーションでも動くことを意味します。サーバーサイドレンダリングやモバイルアプリケーション開発にも React の知識が活用できます。

従来の開発方法と React での開発方法を比較すると、従来の開発では HTML ファイル内にヘッダー、サイドバー、メインコンテンツ、フッターなどを直接記述します。しかし、React ではこれらをコンポーネントごとに分け、JSX ファイルで管理します。これにより、UI の構築がより効率的になります。コンポーネントを使い回すことができるため、コードの記述量が減り、メンテナンス性が向上します。親から子へのデータの受け渡しによって同じコンポーネントで異なる表示をすることもできます。

Next.js を使用することで、ファイルシステムルーティングを簡単に実装できます。例えば、index.js という名前のファイルを変更すると、対応する URL のページが自動的に作成されます。このようにして、ページごとにファイルを管理することができます。

最後に、変更したコードを GitHub にプッシュし、Vercel で自動的にデプロイされる様子を紹介しました。これにより、コードの変更がリアルタイムで Web サイトに反映されることが確認できます。また、Git のブランチ概念や gitmoji を使用したコミットメッセージの書き方についても説明しました。次回の講座ではさらに深く React について学んでいきたいと思います。

## #3 Props を使ってコンポーネントの表示を出し分け！Fragment は使うべき？

今日の React 講座では props について見ていきます。この props に関しては前回のコンポーネント化の知識が必要になりますので、前回のコンポーネント化を見ていない方はそちらから観ていただいて今回の講座に入ってください。今回は、前回コンポーネント化した部分と、インデックスページと about ページを props を使ってうまくコンポーネント化しようと思っています。コードを見ていきますと、インデックス js の下の方に行くと、こちらの部分とこの p タグで囲われた部分を props を使ってコンポーネント化していきます。まずはヘッドライン.js というファイルを作って、全部コピーして入らない部分を削除します。jsx 式には一つの親要素が必要ですが、リブタグで囲むと海藻が増えてしまいます。React Fragment という機能を使うことで解決できますが、個人的にはリブタグで囲むことを推奨しています。これにより、コンポーネントから見て来コンポーネントが一つの要素を返す方が変な混乱を生まずに済むからです。

親コンポーネントからヘッドラインコンポーネントを呼び出し、props を渡します。例えば、インデックス js ではタイトルに「インデックスページ」と設定し、about js では「about ページ」と設定します。ヘッドライン js で props のログを出してみると、親から渡されたデータが確認できます。props は何歳でも渡すことができますが、可読性の点でなるべく少なくすることをお勧めします。また、props の名前はプロパティーズから来ており、データを渡していることを意味します。

最後に、変更したコードを GitHub にプッシュし、Vercel でデプロイします。変更点を確認し、ヘッドライン部分をコンポーネント化するコミットを行います。その後、プッシュが完了し、Vercel でデプロイが完了することを確認します。次回の動画では、props の更なる深い部分について取り扱います。ご視聴ありがとうございました。次回の講座でお会いしましょう。バイバイ。

## #4 Props に色んなデータを渡したり、Children を使ってみよう！

props に数値を渡す際は、クォーテーションを使わずに波括弧を使用します。例えば、about のコンポーネントでナンバーを 111 として渡す場合、数値は波括弧で囲みます。これにより、数値として扱われます。一方で、クォーテーションを使用すると文字列として扱われます。この違いはバグを引き起こす可能性があるため、注意が必要です。

props に配列を渡す場合は、波括弧の中に角括弧を入れて配列を定義します。例えば、[1, 2, 3]という配列を渡す場合、波括弧と角括弧を用いて表現します。

props にオブジェクトを渡す際も波括弧を使いますが、オブジェクトの定義は更に波括弧内に行います。例えば、{foo: "bar"}というオブジェクトを渡す場合、波括弧内にさらに波括弧を用いてオブジェクトを定義します。

真偽値を props として渡す場合、true や false と直接記述します。また、true を省略形で渡すことも可能です。省略形では、プロパティ名を記述するだけで true が渡されます。false を渡す場合は明示的に false を記述する必要があります。

JSX を props として渡す場合は、コンポーネントの開始タグと終了タグの間に JSX を記述します。これにより、子コンポーネントは props として受け取ることができます。

関数（メソッド）も props として渡すことができます。例えば、ボタンの onClick イベントで親から渡された関数を実行するように設定することができます。この方法で、親コンポーネントで定義された関数を子コンポーネントで利用することが可能です。

props の children を使う方法では、コンポーネントの開始タグと終了タグの間に配置された要素が自動的に children として渡されます。この方法は、特に名前を付けずにコンポーネントに渡される要素を扱うのに便利です。

最後に、不要なコードを削除してリファクタリングを行い、変更を GitHub にプッシュし、Vercel でデプロイします。これにより、コードの整理と更新が行われ、アプリケーションが最新の状態に保たれます。

props について詳しく見てきましたが、React 開発において非常に重要な概念ですので、しっかりとマスターしてください。次回の講座では React に関する他の重要なトピックを扱いますので、引き続きご視聴いただけると幸いです。次回の動画でお会いしましょう。バイバイ。

## #5 CSS Modules を使うと CSS の管理が楽になる

この動画では、Next.js における CSS モジュールの利用方法について学びます。CSS モジュールは、Next.js に備わっている機能で、CSS の管理を容易にします。CSS モジュールの利点は、CSS の管理が非常にシンプルになることです。従来の CSS 管理では、クラス名が他の場所で再利用されることが多く、表示が崩れる可能性がありました。これを解決するために BEM（Block Element Modifier）のような命名規則が用いられてきましたが、CSS モジュールを使用することで、よりスマートにこの問題を解決できます。

Next.js では、.module.css という拡張子を使って CSS モジュールを作成します。これにより、クラス名が他のコンポーネントと衝突することなく、個別のスタイルを適用できます。CSS モジュールの使用例として、インデックスページやコンポーネントのスタイルがデモンストレーションされます。ここで、CSS モジュールのクラス名は JavaScript オブジェクトのように扱われ、コンポーネントにスタイルを適用する際には className 属性を使用します。

この動画では、CSS モジュールのリファクタリングも行います。各コンポーネントに関連するスタイルを個別の CSS モジュールファイルに分割し、コンポーネントのメンテナンス性と可読性を高めます。また、CSS モジュールでは、同じクラス名を異なるコンポーネントで使用しても、Next.js が各クラスに固有の識別子を割り当てるため、スタイルの衝突を回避できます。

さらに、Next.js でのグローバルスタイルの定義方法も説明されます。グローバルスタイルは、\_app.js で定義され、サイト全体に適用されます。これにより、コンポーネント固有のスタイルとグローバルスタイルを適切に分離し、管理を効率化できます。

最後に、変更を GitHub にプッシュし、Vercel を使ってデプロイするプロセスが紹介されます。これにより、学んだ内容を実際のプロジェクトに適用し、オンラインで公開する方法を理解できます。

## #6 Link コンポーネントを使って高速なページ遷移を実現しよう！

この動画では、Next.js のリンクコンポーネントの使用方法とその利点について解説しています。通常、Web ページで画面遷移を制御する際には、`<a>`タグを使用しますが、Next.js ではリンクコンポーネントの使用が推奨されます。このコンポーネントを使うことで、ページ間のナビゲーションが高速になり、より良いユーザーエクスペリエンスを提供できます。

動画の初めに、インデックスページとアバウトページでの画面遷移のデモンストレーションがあります。その後、ヘッダーコンポーネントを作成し、インデックスとアバウトページにリンクを配置します。ここで、通常の`<a>`タグではなく、Next.js のリンクコンポーネントを使用する方法を説明しています。

Next.js のリンクコンポーネントの使用は、ページの再読み込みを防ぎ、ページ遷移を高速化するという大きな利点があります。また、リンクコンポーネントはプリフェッチ機能を有効にすることで、ユーザーがリンクにホバーした際に、次のページのデータをバックグラウンドで事前に読み込むことができます。これにより、ページ遷移時のパフォーマンスが向上します。

動画の後半では、リンクコンポーネントのスタイリング方法についても説明しています。ヘッダーコンポーネントにスタイルを適用し、リンクの見た目を改善します。また、Next.js 公式ドキュメントでリンクコンポーネントの詳細情報を得る方法も紹介されています。

最後に、変更を GitHub にプッシュし、Vercel を使ってデプロイするプロセスを実演しています。これにより、学んだ内容を実際のプロジェクトに適用し、オンラインで公開する方法を理解できます。

## #7 コンポーネントを繰り返すときは map をよく使います！

この動画では、React と Next.js を使用した繰り返し処理の実装方法について学びます。通常、繰り返し処理には for ループが使われますが、React コンポーネントの繰り返しには map 関数が用いられます。この動画では、map 関数を使って複数のコンポーネントを効率的に繰り返し表示する方法を解説しています。

まず、複数のリンクを表示する例を通じて、繰り返し処理の基本的なアプローチを説明します。リンクのデータを配列に格納し、map 関数を使ってそれぞれのリンクを効率的に生成します。このプロセスを通じて、データと処理を分離するリファクタリングの重要性を強調しています。

動画では、繰り返し処理の際に React の key プロップスの重要性も説明しています。リストの各要素に一意の key を割り当てることで、React がコンポーネントの状態を正確に追跡できるようになります。

また、HTML エンティティと React の扱いについても解説されています。React では、HTML エンティティを文字列として表示する際に、エスケープ処理が必要である点を指摘しています。さらに、動的な HTML エンティティを使用する際の対策方法についても説明しています。

最後に、変更内容を GitHub にプッシュし、Vercel を使ってデプロイするプロセスを実演しています。これにより、学んだ内容を実際のプロジェクトに適用し、オンラインで公開する方法を理解できます。

## #8 js と jsx どっち？ディレクトリ構成は何がいい？絶対パスインポートはどうやるの？\_app ってどう使うの？

この動画では Next.js を使用したリファクタリングの方法について詳しく説明されています。特に、ファイル拡張子の変更、ディレクトリ構造の最適化、相対パスから絶対パスへの変更など、コードの可読性と効率性を向上させるためのテクニックが紹介されています。

まず、.js 拡張子を.jsx に変更することで、VS Code が React ファイルとして認識し、適切なサポートを提供するようになると説明しています。これにより、開発者は React 特有の構文や機能を効率的に利用できるようになります。

ディレクトリ構造に関しては、components、pages、styles などのフォルダを src ディレクトリにまとめることを提案しています。これにより、プロジェクトの構造が整理され、ファイルへのアクセスが容易になります。

また、相対パスから絶対パスへの変更についても詳しく説明しています。jsconfig.json ファイルを設定することで、プロジェクト内の任意の場所からコンポーネントやスタイルを絶対パスで簡単にインポートできるようになると述べています。

さらに、\_app.jsx ファイルの重要性についても触れています。このファイルは、Next.js プロジェクトにおいて、グローバルなスタイルやレイアウトを定義するのに適していると説明されています。例として、ファビコンや共通ヘッダー・フッターの設定を\_app.jsx に統合する方法が示されています。

最後に、プロジェクトのリファクタリングが完了したら、変更を GitHub にプッシュし、Vercel でデプロイするプロセスが説明されています。

この動画は、React と Next.js を使ったウェブ開発におけるリファクタリングのベストプラクティスを理解するのに役立つ内容です。

## #9 クリックイベント（onClick）はどう扱う？メソッド（関数）の書く位置はどこがオススメ？

この動画では、Next.js を使用した React のイベント処理について説明されています。具体的には、ユーザーがボタンをクリックした際の処理方法に焦点を当てています。

まず、基本的なボタンの配置と onClick イベントの使用方法が紹介されます。ボタンに onClick 属性を追加し、クリックされた際に実行される関数を定義することで、イベントハンドリングが実現されます。例として、クリック時にアラートを表示する簡単な関数が示されています。

次に、イベントオブジェクトの使用方法が説明されます。イベントオブジェクトを利用することで、例えば e.preventDefault()を使用してデフォルトのイベント動作を防止したり、e.target を使用してイベント発生元の要素にアクセスする方法が解説されています。

また、異なる方法でイベントハンドラーを記述する方法も紹介されています。これには、コンポーネント内に直接関数を書く方法、コンポーネント外に関数を定義する方法、アロー関数を使用する方法などが含まれます。

さらに、useCallback フックの使用が紹介されています。useCallback を使用することで、コンポーネントが再レンダリングされても関数が再生成されないようにし、パフォーマンスの最適化を図ることができます。

最後に、変更内容を GitHub にプッシュし、Vercel でデプロイするプロセスが説明されています。

この動画は、React でのイベント処理の基本から、より高度なテクニックまでを網羅しており、Next.js と React を使用したウェブ開発において、イベントハンドリングの理解を深めるのに役立つ内容です。

## #10 useEffect とライフサイクルを理解して、ページが読み込まれたときにイベントを設定してみよう

この動画では、Next.js を使用した React のイベント処理とコンポーネントのライフサイクルについて説明されています。具体的には、イベント処理の 2 つの主要なタイプと useEffect フックの使用について解説されています。

#### イベント処理の 2 つのタイプ

ユーザーのアクションによるイベント: これは、ユーザーがクリック、スクロール、キーボード入力などのアクションを行うことで発生するイベントです。
自動的に発生するイベント: これはユーザーのアクションに依存せず、特定のタイミングや条件で自動的に発生するイベントです。例えば、ブラウザの読み込み完了時やオンライン/オフライン状態の変更時などがあります。

#### コンポーネントのライフサイクル

React のコンポーネントには「ライフサイクル」があり、これはコンポーネントが生成されてから破棄されるまでの一連のプロセスを指します。主に「マウント」（コンポーネントが画面に初めて挿入される時）と「アンマウント」（コンポーネントが破棄される時）の段階に焦点を当てています。

#### useEffect フックの使用

このフックは、コンポーネントのライフサイクルに基づいて特定の副作用（サイドエフェクト）を実行するために使用されます。例として、コンポーネントがマウントされた時に背景色を変更し、アンマウントされた時に元の色に戻すデモが示されました。useEffect は、マウント時に副作用を実行し、アンマウント時にクリーンアップ処理を行うために使われます。

#### 注意点

直接 DOM 要素を操作することは React のパラダイムに反しているため、基本的には避けるべきです。特に、React が管理する DOM 要素（例えば、Next.js の\_\_next 要素内部）に直接アクセスして変更を加えることは推奨されません。代わりに、React の ref システムを利用することが推奨されます。

最後に、変更を GitHub にプッシュして Vercel でデプロイするプロセスが説明されています。これにより、変更が適切にライブ環境に反映されることが確認されます。

この動画は、React のイベント処理、コンポーネントのライフサイクル、そして useEffect フックの基本から応用までを網羅しており、Next.js を使用した Web 開発における重要なコンセプトの理解に役立ちます。

## #11 useState の状態管理について解説！君は setState に関数を使っているか？

このビデオでは、React の useState フックを使ったステート管理と、そのステートを更新する方法について説明されています。

主な内容
カウンターの実装: ボタンをクリックするとカウントがアップするカウンターを実装するプロセスが示されます。

useState の基本: useState フックを使ってステートを作成し、そのステートを更新する方法が説明されます。初期値として 1 を設定し、ボタンをクリックするたびにこの数値が増加します。

ステートの更新方法: ステートを直接変更する（useState の戻り値であるセッター関数を使う）方法と、関数を使って前のステートに基づいて新しいステートを生成する方法が説明されます。後者はステートの依存関係に基づいてより安定した更新を提供します。

配列の分割代入: useState から返される配列（ステート変数とその更新関数）を分割代入する方法が示されます。

命名規則: ステート変数とセッター関数の命名規則について説明されます。一般的にステート変数名（例：count）に基づいてセッター関数を命名します（例：setCount）。

コンポーネントの再レンダリング: ステートが更新されるとコンポーネントが再レンダリングされることが説明されます。この挙動を通じて React がどのように UI を最新の状態に保つかを理解します。

GitHub にプッシュ & Vercel にデプロイ: 完成したコードを GitHub にプッシュし、Vercel でデプロイするプロセスが示されます。

このビデオは、React でのステート管理の基礎を学ぶのに役立ちます。useState フックを使うことで、動的に変化するデータを扱い、ユーザーインタラクションに応じて UI を更新する方法を理解することができます。

## #12 useEffect や useCallback の第 2 引数の配列について理解を深めよう

このビデオでは、React の useEffect と useCallback フックの詳細な説明が行われています。

#### 主な内容

useEffect の第 2 引数の説明: useEffect フックの第 2 引数に変数を指定することによって、その変数が変更されたときに副作用が再実行される方法が説明されます。また、副作用のクリーンアップ関数がどのように動作するかも示されています。

useCallback の挙動確認: useCallback フックの挙動が示され、第 2 引数に指定した変数が変更されたときに関数が再生成されることが説明されます。このフックはパフォーマンスの最適化のために使用されることが強調されています。

変数の更新とパフォーマンス: 第 2 引数の配列に複数の変数を指定することができ、これらの変数のいずれかが変更されたときに副作用が再実行される点が説明されます。これにより、コンポーネントのパフォーマンスを向上させることができます。

useMemo の存在: useMemo フックについても簡単に触れられ、このフックも同様に第 2 引数の配列を用いてメモ化された値を管理することができると説明されます。

コードの GitHub へのプッシュと Vercel によるデプロイ: ビデオの最後に、講師はビデオで使用したコードを GitHub にプッシュし、Vercel を使ってデプロイする過程を実演します。

このビデオは、useEffect と useCallback フックを理解し、React のコンポーネント内でパフォーマンスを最適化する方法を学ぶのに役立ちます。また、これらのフックが React のアプリケーションの挙動にどのように影響を与えるかについての洞察も提供しています。

## #13 useState で文字列（string）や真偽値（boolean）を扱ってみよう

このビデオでは、React の useState フックを使用して様々なデータタイプを扱う方法について説明されています。

主な内容
文字列の扱い方: useState を使用して文字列を扱う方法が示されます。テキスト入力要素で文字列の状態を更新し、その動作を確認します。さらに、文字列の長さ制限やトリミング処理など、文字列の制御方法も説明されます。

真偽値の扱い方: 次に、真偽値（boolean）を useState で扱う方法について解説されます。特定の条件に基づいて UI の表示・非表示を切り替える方法が示され、三項演算子の使用が強調されます。

簡潔なコードの書き方: 真偽値を反転させる際のコードをより簡潔にする方法が紹介されます。これには、論理演算子（!）を使用し、よりコンパクトなコードにリファクタリングする技法が含まれます。

GitHub へのプッシュと Vercel によるデプロイ: ビデオの最後に、開発したコードを GitHub にプッシュし、Vercel でのデプロイを実演します。

このビデオは、React での状態管理の基本を学ぶのに非常に有用です。特に、異なるデータタイプを useState フックでどのように扱うか、また、コードをより効率的かつ簡潔に記述する方法に焦点を当てています。

## #14 イミュータブルや破壊的メソッドを理解しよう！スプレッド構文を使う理由とは！？

このビデオでは、React の useState を使用して配列を扱う方法について詳しく説明されています。主な内容は以下の通りです。

useState で配列を扱う準備: useState を使って配列の状態を管理する方法が紹介されます。配列をループして DOM に表示する方法や、ボタンをクリックすることで配列の要素を増やす方法も説明されます。

スプレッド構文の使用: JavaScript のスプレッド構文を使用して、破壊的でない方法で配列の要素を追加する方法が解説されます。これはモダン JavaScript の重要な概念であり、破壊的メソッド（例: push）と非破壊的メソッドの違いを理解することが強調されます。

ミュータブルとイミュータブル: JavaScript でのミュータブル（変更可能）とイミュータブル（変更不可能）なデータの扱い方について説明されます。特に、React ではイミュータブルなデータの扱いが重要であることが強調されます。

配列の破壊的メソッド: 配列に対する破壊的メソッド（例: pop, push, splice）の使用は避けるべきであり、代わりにスプレッド構文を使うべきであると説明されます。

テキスト入力を配列に追加: テキスト入力を配列に追加する方法として、入力されたテキストを配列に追加する方法が実演されます。

GitHub に push & Vercel にデプロイ: 最後に、開発したコードを GitHub にプッシュし、Vercel でデプロイするプロセスが示されます。

このビデオは、React における状態管理の高度な側面と、モダン JavaScript の重要な概念について理解を深めるのに役立ちます。

## #15 Custom Hooks（カスタムフック）の使い方、使いどころをマスターしよう！

このビデオでは、Next.jsを使用したReactのカスタムフックについての講座が行われています。主な内容は以下の通りです。

カスタムフックの作成: ステートとイベントハンドラーをカスタムフックにまとめる方法が説明されます。これによりコードの再利用性が向上し、複数のコンポーネント間で同じロジックを簡単に共有できるようになります。

コンポーネントへの適用: 作成したカスタムフックを様々なコンポーネントに適用し、その使い方とメリットについて詳しく説明されます。

useEffectのカスタムフック化: useEffectフックもカスタムフックに組み込む方法が示され、さらにコードの整理と効率化が行われます。

フックのルールについて: Reactフックの基本ルールについて解説され、これらのルールに従うことでどのようにコードの可読性と保守性が向上するかについて説明されます。

カスタムフックとコンポーネントの違い: カスタムフックと伝統的なコンポーネントの違いについて解説され、各々の使用シナリオに応じた選択肢が提供されます。

GitHubへのpushとVercelによるデプロイ: 最後に、作成したコードをGitHubにプッシュし、Vercelでデプロイするプロセスが実演されます。

このビデオは、Next.jsとReactのカスタムフックを理解し、実践的に適用する方法を学ぶのに役立ちます。

#### #16 Stateのリフトアップでページ間やコンポーネント間で値を共通化しよう！

このNext.jsでのReact講座では、ステートのリフトアップについて詳しく解説されています。主な内容は以下の通りです。

Next.jsの特性を活かしたステートのリフトアップ: Next.jsの特有の構造を利用して、ページ間でステート（状態）を共有する方法が説明されます。この方法では、_app.jsxを使用してステートを共通化し、各ページのコンポーネントにpropsとして渡す方法が示されています。

コンポーネント間でのステート共有: コンポーネント間でステートを共有するためのリフトアップ方法が説明されます。これは、親コンポーネントでステートを管理し、子コンポーネントにpropsとして渡すことで、異なるコンポーネント間で状態を共有します。

実践的なデモ: コンポーネントのステートをリフトアップする実際のプロセスが示され、具体的なコードの例を通じて、リフトアップのプロセスが詳しく解説されています。

ステートのリフトアップの応用: ステートのリフトアップを利用して、異なるコンポーネントで同じステートを使用する方法が示され、ステートの管理の柔軟性が強調されています。

GitHubへのpushとVercelによるデプロイ: 最終的に、行った変更をGitHubにプッシュし、Vercelを通じてデプロイするプロセスが実演されています。

この講座は、Next.jsおよびReactのステートのリフトアップの基本的な概念と実践的な適用方法を理解するための有益なリソースとなっています。


#### #18 ReactでAPIを叩こう！Next.jsのESLintの設定もついでに紹介！
このビデオはNext.jsに関するプログラミング講座を提供しています。講座は基礎から応用編へと進み、簡単なアプリケーションやブログの作成を通じて学ぶ内容です。今回のトピックはESLintの導入とNext.jsのバージョンアップ、そしてESLintのエラー解決方法についてです。また、APIの叩き方も説明しており、非同期処理を行って結果を取得し、画面に表示する方法を解説します。

講座では、JSONPlaceholderというダミーのAPIを使用し、非同期処理を使ってデータを取得し、Reactのステートに保存する方法を紹介します。これには、useEffectやuseStateといったReactのフックスが使用されます。また、データの表示方法として、マッピングや条件付きレンダリングを使った方法が説明されます。

最後に、初心者がよく犯すミスとして、初期値の設定の重要性や、三項演算子と短絡評価の使用方法について触れています。次回の講座では、ローディング状態の取り扱いやエラーハンドリングについて学ぶ予定です。

#### #19 非同期処理で必要になるローディングとエラーの処理について学ぼう

このビデオでは、APIを叩く際のローディングとエラー状態の取り扱い方法について解説しています。まず、前回の変更点をコミットし、次にローディング状態の実装方法を説明しています。ネットワークタブを用いてスローアクセス環境を模擬し、ローディング中の表示方法をデモンストレーションします。

続いて、ローディング状態を管理するためのuseStateフックの使用方法を説明し、実際のコード例を通じて実装を行っています。さらに、エラー状態を追加する方法も紹介し、try-catch文を用いて非同期処理中のエラーハンドリング方法を解説しています。

その後、コードのリファクタリングを行い、非同期処理のロジックを別のコンポーネントに分ける方法を示しています。これにより、コードがよりクリーンで読みやすくなります。また、fetch後にデータが無かった場合の処理も追加し、データが空の場合に「データはありません」と表示するようにしています。

最後に、GitHubにpushし、Vercelにdeployする過程を実演します。これにより、変更点が実際のウェブサイトに反映される様子を見ることができます。また、次回の講座では、レンダリングの最適化と外部パッケージを使った非同期処理の簡素化について取り上げる予定です。

#### #20 useReducerの使い方を学ぼう
この講座では、useReducer フックについて学んでいます。まず、前回は非同期処理のローディングとエラーについて扱いました。今回は、useState フックを使った複数の状態管理を useReducer に置き換え、より効率的な状態管理方法を学びます。主に、useReducer の利点として、複数の値にまたがる複雑な状態ロジックや、前の状態に基づいて次の状態を決める必要がある場合に適している点が挙げられます。

具体的には、useReducer を用いて、ローディング、エラー、データの状態を一つの状態オブジェクトで管理します。この方法により、複数の useState フックを使うよりも、状態管理が明確になり、コードの可読性が向上します。また、状態更新のロジックをリデューサー関数に集約することで、より宣言的で予測しやすいコードを書くことが可能になります。

講座では、useReducer の基本的な使い方、アクションの定義、ディスパッチの方法について詳しく解説しています。最後に、GitHubにプッシュし、Vercelでデプロイする過程も実演しています。次回の講座では、useReducer をさらに発展させ、外部ライブラリを使用した簡単な使い方を紹介する予定です。

#### #21 SWRを使った非同期処理（fetch）

この講座では、ライブパッケージのSWRを使って非同期処理を行う方法を学びます。以前はuseReducerを使って非同期処理の状態管理を行っていましたが、今回はそれをSWRに置き換えます。非同期処理は自作するより外部パッケージを使う方が効率的で、特に初心者にはおすすめです。SWRは機能豊富で簡単に非同期処理が実装でき、Next.jsとの親和性も高いです。

SWRをインストールし、基本的な使い方を紹介します。SWRを使うと、データ取得、エラーハンドリング、ローディング状態の管理が簡単になり、コード量が大幅に減ります。さらに、カスタムフックを使ってSWRをさらに使いやすくする方法も説明します。カスタムフックを使うことで、コンポーネント間で非同期処理を簡単に共有できます。

最後に、変更をGitHubにプッシュし、Vercelでデプロイする過程を実演します。この講座では、クライアントサイドでの非常に重要な非同期処理の基礎を学ぶことができます。